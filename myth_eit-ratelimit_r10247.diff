Index: libs/libmythtv/eithelper.h
===================================================================
--- libs/libmythtv/eithelper.h.orig	2006-06-20 17:31:09.000000000 -0400
+++ libs/libmythtv/eithelper.h	2006-06-20 17:36:06.000000000 -0400
@@ -20,7 +20,10 @@
 {
     Q_OBJECT
   public:
-    EITHelper() : QObject(NULL, "EITHelper") { ; }
+    EITHelper() : QObject(NULL, "EITHelper") 
+    { 
+        events_full = false; 
+    }
 
     void ClearList(void);
     uint GetListSize(void) const;
@@ -28,6 +31,8 @@
 
   public slots:
     void HandleEITs(QMap_Events* events);
+  signals:
+    void StopParsing(bool);
 
   private:
     int GetChanID(int tid_db, const Event &event) const;
@@ -39,6 +44,12 @@
 
     /// Maximum number of DB inserts per ProcessEvents call.
     static const uint kChunkSize;
+
+    // Max event list size before we stop parsing incoming events
+    // allowing us to try and catchup.
+    static const uint kMAXChunkSize;
+
+    bool events_full;
 };
 
 #endif // USING_DVB
Index: libs/libmythtv/siparser.cpp
===================================================================
--- libs/libmythtv/siparser.cpp.orig	2006-06-20 17:36:06.000000000 -0400
+++ libs/libmythtv/siparser.cpp	2006-06-20 17:37:04.000000000 -0400
@@ -64,6 +64,8 @@
     ParserInReset(false),           standardChange(false),
     PrivateTypesLoaded(false)
 {
+    events_full = false;
+
     /* Set the PrivateTypes to default values */
     PrivateTypes.reset();
 
@@ -571,6 +573,12 @@
     (void) pid;
 #endif
 
+    if (events_full)
+    {
+        pmap_lock.unlock();
+        return;
+    }
+
     if (!(buffer[1] & 0x80))
     {
         VERBOSE(VB_SIPARSER, LOC + 
Index: libs/libmythtv/eithelper.cpp
===================================================================
--- libs/libmythtv/eithelper.cpp.orig	2006-06-20 17:31:09.000000000 -0400
+++ libs/libmythtv/eithelper.cpp	2006-06-20 17:36:06.000000000 -0400
@@ -4,7 +4,11 @@
 #include "eithelper.h"
 #include "mythdbcon.h"
 
-const uint EITHelper::kChunkSize = 20;
+
+// TODO: Should these be configurable values based on how much ram a 
+// backend has available?
+const uint EITHelper::kChunkSize = 50;
+const uint EITHelper::kMAXChunkSize = 1000;
 
 static int get_chan_id_from_db(int tid_db, const Event&);
 static uint update_eit_in_db(MSqlQuery&, MSqlQuery&, int, const Event&);
@@ -75,35 +79,45 @@
     if (!eitList.size())
         return 0;
 
+    //VERBOSE(VB_EIT,QString("EITHelper::ProcessEvents: Events: %1/%2")
+    //        .arg(eitList.size()).arg(eitList.front()->size()));
+
     uint insertCount = 0;
-    if (eitList.front()->size() <= kChunkSize)
+
+    QList_Events  subset;
+    while (subset.size() < kChunkSize && eitList.size())
     {
         QList_Events *events = eitList.front();
-        eitList.pop_front();
-
-        eitList_lock.unlock();
-        insertCount += UpdateEITList(mplexid, *events);
-        QList_Events::iterator it = events->begin();
-        for (; it != events->end(); ++it)
-            delete *it;
-        delete events;
-        eitList_lock.lock();
+        while (subset.size() < kChunkSize && events->size())
+        {
+            subset.push_back(events->front());
+            events->pop_front();
+        }
+        if (! events->size())
+        {
+            eitList.pop_front();
+            delete events;
+        }
     }
-    else
+
+    eitList_lock.unlock();
+    insertCount += UpdateEITList(mplexid, subset);
+    QList_Events::iterator it = subset.begin();
+    for (; it != subset.end(); ++it)
+        delete *it;
+    eitList_lock.lock();
+
+    if (((eitList.size() <= kChunkSize) && events_full) 
+          || ((eitList.size() > kMAXChunkSize) && !events_full))
     {
-        QList_Events *events = eitList.front();
-        QList_Events  subset;
+        int size = eitList.size();
+        VERBOSE(VB_GENERAL, QString ("EITHelper: ToggleParsing EIT (%1)")
+                                      .arg(size));
+
+        events_full = (size > kMAXChunkSize);
 
-        QList_Events::iterator subset_end = events->begin();
-        for (uint i = 0; i < kChunkSize; ++i) ++subset_end;
-        subset.insert(subset.end(), events->begin(), subset_end);
-        events->erase(events->begin(), subset_end);
-        
         eitList_lock.unlock();
-        insertCount += UpdateEITList(mplexid, subset);
-        QList_Events::iterator it = subset.begin();
-        for (; it != subset.end(); ++it)
-            delete *it;
+        emit(StopParsing(events_full));
         eitList_lock.lock();
     }
 
Index: libs/libmythtv/eitscanner.cpp
===================================================================
--- libs/libmythtv/eitscanner.cpp.orig	2006-06-20 17:31:09.000000000 -0400
+++ libs/libmythtv/eitscanner.cpp	2006-06-20 17:36:06.000000000 -0400
@@ -176,6 +176,8 @@
             eitHelper, SLOT(HandleEITs(QMap_Events*)));
     connect(channel,   SIGNAL(UpdatePMTObject(const PMTObject *)),
             this,      SLOT(SetPMTObject(const PMTObject *)));
+    connect(eitHelper, SIGNAL(StopParsing(bool)),
+            parser,    SLOT(StopParsing(bool)));
 }
 
 /** \fn EITScanner::StopPassiveScan(void)
Index: libs/libmythtv/siparser.h
===================================================================
--- libs/libmythtv/siparser.h.orig	2006-06-20 17:36:06.000000000 -0400
+++ libs/libmythtv/siparser.h	2006-06-20 17:37:04.000000000 -0400
@@ -116,6 +116,8 @@
 
   public slots:
     virtual void deleteLater(void);
+    void StopParsing(bool stop)
+         { pmap_lock.lock(); events_full = stop; pmap_lock.unlock(); }
 
   signals:
     void FindTransportsComplete(void);
@@ -240,6 +242,9 @@
     QDateTime ServiceSearchEndTime;
     QDateTime EventSearchEndTime;
 
+    // Rate Limit
+    bool events_full;
+
     // Common Variables
     int                 SIStandard;
     uint                CurrentTransport;
